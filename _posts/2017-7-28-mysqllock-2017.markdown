---
layout:     post
title:      "关于mysql数据库锁机制的个人理解"
subtitle:   " \"mysql数据库锁机制解析\""
date:       2017-08-10 14:44:00
author:     "Htt"
header-img: "img/post-bg-os-metro.jpg"
catalog: true
tags:
    - 数据库
---
> “生命不息，砥砺前进 ”


## 前言
这个Blog其实两个月前就建立了，由于种种原因（懒）,一直没有更新，这两天项目上线，
又按耐不住自己追求进步的心！---赞 ^_^
<br>
本文主要和大家一起分析，innolDB存储引擎下的锁机制原理和加锁场景。
## 正文
首先要分析mysql锁机制之前明确几个概念：S/X锁（共享锁/排它锁），事务隔离级别，当前读/快照读

  S/X锁（共享锁/排它锁）：在mysql InnoDB引擎下，是由MVCC（多版本并发控制协议）来实现的，
  现在大部分的存储引擎基本都支持MVCC，他的好处就是：读不加锁，写加锁，读写不冲突，处理数据更快，写操作排他锁（X锁），被X锁锁住的数据是不能加任何其他锁的。但是因为读不加锁，所以会造成跟多问题，由此又引出了第二个概念--当前读/快照读

 当前读/快照读：在MVCC中，支持者两种读取方式，主要区别是：快照读对数据不加锁，读取的是当前事务的快照版本，该版本可能是过时的，因此会出现脏读，但是效率快。当前读对数据加锁（具体锁类型后面分析），读取当前数据库中的真实数据，在读取数据的是事务里，数据一直被锁定，不会出现脏读，但是效率慢。

下面根据sql来分析：
```
1: select * from table ...                         //快照读  不加锁
​2: select * from table ... lock in share mode;     //当前读  加共享锁
3: select * from table ... for update;             //当前读  加排它锁
```
以上为读数据情况，除此之外，update/delete/insert 均加排它锁

 事务隔离级别：

   * MySQL/InnoDB定义的4种隔离级别：
   * Read Uncommited：读未提交，不会使用；
   * Read Committed (RC)：读已提交级别，该级别下如果是快照读，则会出现不可重复读的问题（数据没加锁，被其他操作更改掉），但是如果是当前读，则不会出现不可重复读的问题，但是还是会存在一个问题--幻读！而所有的写操作，还是像之前我们的介绍一样，对数据加排它锁；
   * Repeatable Read (RR)：可重复读级别，同样，该级别下如果是快照读，则也会出现不可重复读的问题（数据没加锁，被其他操作更改掉）跟RC的情况是一样的，但是如果是当前读，那不但不可重复读的问题没有的而且幻读的问题也没有了，这是因为这个神奇的**gap**锁（间隙锁），顾名思义他会将要锁定的数据范围加锁，这个gap锁的加锁机制跟是否使用索引有很大关联，由于比较啰嗦，以后再分析这点
   * Serializable：序列化级别，读操作均为当前读，写加排它锁，性能最慢

经过以上分析之后，就会发现，日常出现的各种脏读，不可重复读等情况，并不是只由隔离级别就决定的，跟实际使用的读取类型有很大关系。

以上只是根据概念分析，以后会考虑针对明确的sql语句来分析

最最重要的一点，以上仅仅是个人的思考，如有错误，请大家指出，共同进步！

