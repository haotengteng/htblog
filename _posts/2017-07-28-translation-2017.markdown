---
layout:     post
title:      "浅谈分布式事务"
subtitle:   " \"分布式事务个人理解及几种业界解决方案\""
date:       2017-07-28 14:44:00
author:     "Htt"
header-img: "img/post-bg-kuaidi.jpg"
catalog: true
tags:
    - 事务 分布式
---
> “浅谈分布式事务个人理解及几种业界解决方案 ”

## 前言

由于公司项目一直用到了分布式系统，各个SOA服务通过rpc相互调用，
那这就面临一个不可避免的问题就是分布式事务。

## 正文

众所周知，系统的可用性和一致性是成反比的，高可用就必然意味着弱一致，
强一致就必然意味着低性能（前提，机器性能不变）
但是在大型的复杂互联网系统中，为了承载更多的用户请求，
一般都是通过提高系统可用性，同时最求最终一致性来实现的。

那处理分步式事务的方案大体有以下几种：

* 二阶段提交事务，这种方式就是有一个事务调度器，请求打进来之后，向各个节点发布信息，需要提交了，做好准备，然后等待节点回应，节点准备好后，都需要向事务调度器回复“准备好了”，然后事务调度器就再次向所有节点发信息"大家一起提交"，于是所有节点一起提交，在此期间如果有某个节点没有回应挥着回应失败，那么调度器会通知所有节点回滚数据。这种方式的缺点本明显：大事务，承载能力弱，（不建议使用）

* 基于消息机制解决，这种方案的是通过依赖消息的可靠性和信息持久化来实现的，比如一个转账场景，A-->B，转账事务接收到转账请求之后，先在本地事务处理插入账单等操作，然后通过MQ发消息给底层账务系统执行扣款，其中要求查入账单后必须要执行转账，首先部分MQ中间件比如（rabbitmq是支持事务持久化的但是性能会下降很多），在这里我一直使用的MQ的确认机制，如果消息发送队列成功（持久化的消息，持久化成功）后，就会回调生产者，返回一个ACK回应，如果接受失败则会返回NACK回应，那么这样我们就可以对消息进行重发，当然消费端要做好幂等，防止消息重推。消息到了队列以后，消费者也要开启确认机制，业务处理成功之后发起ACK回复，失败发起NACK回复，此时如果失败消息不会删除而是会重新选择消费者（如果有集群的话）发送；通过这些举措来保证消息的可靠性，账务处理完成后，同样异步消息告诉账单服务，完成订单状态的修改。

* 支付宝模式）也是基于消息机制，进入本地事务以后，向RocketMQ（支付宝参照kafka实现的消息中间件）集群发布交易消息，但是这条消息不会被立即发送，而是存储起来，本地事务处理完成，事务提交以后，在通知集群发送交易消息，mq集群接收到后，通知交易系统（此处省略一大坨，具体支付宝转账是扣款和加款异步，也就是现在描述的过程），但是这个过程中会出现一个问题，那就是本地事务提交后成功后。通知mq集群发消息失败，因此，还有一个定时检查一通，轮询检查mq集群中的未发送的消息，然后查询交易记录（此处感觉要耦合业务了/(ㄒoㄒ)/~~，不知道支付宝是怎么处理的），根据交易记录来作相应处理，当然消费端的幂等性一定要做好。

    以上三种个人了解的对分布式事务解决的方案，其他方案应该也大同小异，其中第二种是我经常用到的，基本上性能和稳定上都没什么问题，推荐大家使用。。

    最后，本文仅是个人观点，如有错误，请大家指出，共同进步！

